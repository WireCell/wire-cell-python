import torch

def get_unchosen_elements(n: int, k: int) -> torch.Tensor:
    """
    Computes the elements that were *not* chosen in each combination
    generated by `torch.combinations(torch.arange(n), k)`.

    Args:
        n (int): The total number of elements (from 0 to n-1).
        k (int): The number of elements chosen in each combination.

    Returns:
        torch.Tensor: A tensor of shape `(num_combinations, n-k)` containing
                      the elements not chosen in each corresponding combination.
                      Returns an empty tensor with the correct second dimension
                      if no combinations exist (e.g., k > n) or if all elements
                      are chosen (k = n).
    """
    # 1. Generate all k-combinations of elements from 0 to n-1
    # Example: n=3, k=2 -> c = [[0, 1], [0, 2], [1, 2]]
    c = torch.combinations(torch.arange(n), k)

    # Handle cases where no combinations are generated (e.g., k > n)
    if c.numel() == 0:
        # Return an empty tensor with the correct number of columns (n-k)
        # and 0 rows, maintaining the expected shape structure.
        return torch.empty((0, n - k), dtype=torch.int64)

    num_combinations = c.shape[0]
    
    # Create a tensor representing all possible elements (0 to n-1)
    all_elements_range = torch.arange(n, dtype=torch.int64)

    # 2. Create a boolean mask to identify chosen elements
    # Initialize a mask of shape (num_combinations, n) with all False values.
    # This mask will indicate for each combination (row) which of the 'n'
    # possible elements (columns) are present.
    mask = torch.zeros((num_combinations, n), dtype=torch.bool)

    # Use `scatter_` to efficiently mark the chosen elements as True.
    # `scatter_(dim, index, src)`:
    # - `dim=1`: We are scattering along the column dimension.
    # - `index=c`: For each row `i` in `mask`, the values in `c[i]` are used
    #              as column indices to set to `True`.
    # - `src=True`: The value to scatter.
    # After this, `mask[i, j]` will be `True` if `j` is in `c[i]`, and `False` otherwise.
    # Example for n=3, k=2, c=[[0,1],[0,2],[1,2]]:
    # mask will become:
    # [[T, T, F],
    #  [T, F, T],
    #  [F, T, T]]
    mask.scatter_(1, c, True)

    # 3. Invert the mask to get the unchosen elements
    # `unchosen_mask` will have `True` where elements were NOT chosen.
    # Example:
    # [[F, F, T],
    #  [F, T, F],
    #  [T, F, F]]
    unchosen_mask = ~mask

    # 4. Extract the actual unchosen values and reshape
    # `nonzero()` returns the coordinates of all non-zero (True) elements.
    # For `unchosen_mask`, `nonzero_indices` will have two columns:
    # - Column 0: The row index (which combination it belongs to).
    # - Column 1: The column index (which is the actual unchosen value).
    # Example: `[[0, 2], [1, 1], [2, 0]]`
    nonzero_indices = unchosen_mask.nonzero()

    # If all elements are chosen (k=n), then `unchosen_mask` will be all False,
    # and `nonzero_indices` will be empty. Handle this case.
    if nonzero_indices.numel() == 0:
        # Return an empty tensor with the correct number of columns (n-k)
        # and `num_combinations` rows, as there are no unchosen elements.
        return torch.empty((num_combinations, n - k), dtype=torch.int64)

    # Extract the unchosen values, which are in the second column of `nonzero_indices`.
    nc_values = nonzero_indices[:, 1]

    # Reshape the flattened list of unchosen values back into the desired shape:
    # `(num_combinations, n - k)`.
    nc = nc_values.reshape(num_combinations, n - k)

    return nc

def test_uncombo():

    # Your specific example: n=3, k=2
    n = 3
    k = 2
    c = torch.combinations(torch.arange(n), k)
    nc = get_unchosen_elements(n, k)

    print(f"Original n: {n}, k: {k}")
    print(f"Combinations (c):\n{c}")
    print(f"Shape of c: {c.shape}")
    print(f"Unchosen elements (nc):\n{nc}")
    print(f"Shape of nc: {nc.shape}\n")

    # Another example: n=4, k=2
    n_ex2 = 4
    k_ex2 = 2
    c_ex2 = torch.combinations(torch.arange(n_ex2), k_ex2)
    nc_ex2 = get_unchosen_elements(n_ex2, k_ex2)

    print(f"Original n: {n_ex2}, k: {k_ex2}")
    print(f"Combinations (c):\n{c_ex2}")
    print(f"Shape of c: {c_ex2.shape}")
    print(f"Unchosen elements (nc):\n{nc_ex2}")
    print(f"Shape of nc: {nc_ex2.shape}\n")

    # Edge case: k=0 (no elements chosen, all are unchosen)
    n_ex3 = 3
    k_ex3 = 0
    c_ex3 = torch.combinations(torch.arange(n_ex3), k_ex3)
    nc_ex3 = get_unchosen_elements(n_ex3, k_ex3)

    print(f"Original n: {n_ex3}, k: {k_ex3}")
    print(f"Combinations (c):\n{c_ex3}")
    print(f"Shape of c: {c_ex3.shape}")
    print(f"Unchosen elements (nc):\n{nc_ex3}")
    print(f"Shape of nc: {nc_ex3.shape}\n")

    # Edge case: k=n (all elements chosen, no unchosen)
    n_ex4 = 3
    k_ex4 = 3
    c_ex4 = torch.combinations(torch.arange(n_ex4), k_ex4)
    nc_ex4 = get_unchosen_elements(n_ex4, k_ex4)

    print(f"Original n: {n_ex4}, k: {k_ex4}")
    print(f"Combinations (c):\n{c_ex4}")
    print(f"Shape of c: {c_ex4.shape}")
    print(f"Unchosen elements (nc):\n{nc_ex4}")
    print(f"Shape of nc: {nc_ex4.shape}\n")

    # Edge case: k > n (no combinations possible)
    # n_ex5 = 3
    # k_ex5 = 4
    # c_ex5 = torch.combinations(torch.arange(n_ex5), k_ex5)
    # nc_ex5 = get_unchosen_elements(n_ex5, k_ex5)

    # print(f"Original n: {n_ex5}, k: {k_ex5}")
    # print(f"Combinations (c):\n{c_ex5}")
    # print(f"Shape of c: {c_ex5.shape}")
    # print(f"Unchosen elements (nc):\n{nc_ex5}")
    # print(f"Shape of nc: {nc_ex5.shape}\n")
